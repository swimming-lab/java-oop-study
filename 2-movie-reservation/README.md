# 2장. 객체지향 프로그래밍

### 영화 예매 시스템

- 요구사항
    - 영화
    - 할인 조건
        - 가격의 할인 여부를 결정하며 ‘순서 조건'과 ‘기간 조건'의 두 종류로 나눈다.
    - 할인 정책
        - 할인 요금을 결정하며 ‘금액 할인 정책'과 ‘비율 할인 정책’의 두 종류로 나눈다.


도메인 구성도

![2-1](https://github.com/swimming-lab/study-java-object/blob/master/2-movie-reservation/2-1.png)


클래스 다이어그램

![2-2](https://github.com/swimming-lab/study-java-object/blob/master/2-movie-reservation/2-2.png)

### 교재 정리

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞춰야 얻을 수 있다.

- 첫째, 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해라. 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
- 둘째, 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다. 다른 객체에게 도움을 주거나 의존하면서 협력하는 공동체의 일원으로 바라보는 것이 설게를 유연하고 확장 가능하게 만든다.

**Template Method 패턴**

부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 방법

**오버라이딩과 오버로딩**

- 오버라이딩
    - 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
    - 자식 클래스의 메서드는 오버라이딩한 부모 클래스의 메서드를 가리기 때문에 외부에서는 부모 클래스의 메서드가 보이지 않는다.
- 오버로딩
    - 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다르다.
    - 오버로딩한 메서드는 원래의 메서드를 가리지 않기 때문에 사이 좋게 공존한다.

**상속과 인터페이스**

- 상속
    - 두 클래스 사이의 관계를 정의하는 방법이고 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.
    - 상속관계를 선엄함으로써 한 클래스는 자동으로 다른 클래스가 제공하는 코드를 자신의 일부로 합칠 수 있다.
    - 코드 중복을 제거하고 여러 클래스 사에이서 동일한 코드를 공유할 수 있게 된다.
- 인터페이스
    - 객체가 이해할 수 있는 메시지의 목록을 정의하는 것이다.


**업캐스팅**

자식 클래스는 상속을 통해 부모 클래스의 모든 인터페이스를 물려받기 때문에 부모 클래스 대신 사용될 수 있다.

컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스를 사용하는 것을 허용한다.

이처럼 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 한다.

이유는 클래스 다이어그램을 그릴 때 부모 클래스가 자식 클래스보다 위에 위치하기 때문이라고 한다.

**다형성**

메시지와 메서드는 다른 개념이다.

코드 상에서 특정 클래스에게 메시지를 전송하지만 실행 시점에 실제로 실행되는 메서드는 달라질 수 있다.

동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있는 사실을 기반으로 한다.

이처럼 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.

구현 방법

- 메시지와 메서드를 실행 시점에 바인딩하는 벙법을 지연 바인딩(Lazy), 동적 바인딩(Dynamic)이라고 한다.
- 전통적인 함수 호출처럼 컴파일 시점에 결정하는 것을 초기 바인딩(Early), 정적 바인딩(Static)이라고 한다.

**상속의 단점**

- 상속이 캡슐화를 위반한다.
    - 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
    - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    - 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다.
    - 결과적으로 과도한 상속은 변경이 어려워진다.
- 설계를 유연하지 못하게 만든다.
    - 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
    - 최선의 방법은 setter 메서드를 이용하여 주입받은 인스턴스를 바꾸는 방법이다.


**합성**

인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 합성이라 한다.

다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.

합성은 상속의 두 가지 문제점을 해결한다.

- 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
- 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
-

상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 메시지를 통해 느슨하게 결합된다.

따라서 코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.

**마무리**

대부분의 사람들은 객체지향 프로그래밍 과정을 클래스 안에 속성과 메서드를 채워넣는 작업이나 상속을 이용해 코드를 재사용하는 방법 정도로 생각한다. 너무 프로그래밍 관점에 치우쳐서 객체지향의 본질을 놓치기 쉽다.

객체지향이란 객체를 지향하는 것이다. 따라서 객체지향 패러다임의 중심에는 객체가 위치한다. 그러니 객체를 따로 떼어 놓고 이야기하는 것은 무의미하며, 객체지향에서 가장 중요한 것은 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다. 객체들은 협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행한다.
